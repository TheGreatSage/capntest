// Code generated by bebop; DO NOT EDIT.

package beop

import (
	"io"
	"wellquite.org/bebop/runtime"
)

type FakeMessage struct {
	Email    string
	Ip       string
	Username string
	Rfc3339  string
	Unix     int64
	Uuid     string
	Ran      uint32
}

var _ runtime.Bebop = (*FakeMessage)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *FakeMessage) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *FakeMessage) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *FakeMessage) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *FakeMessage) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *FakeMessage) SizeBebop() int {
	return 4 + len(self.Email) + 4 + len(self.Ip) + 4 + len(self.Username) + 4 + len(self.Rfc3339) + 8 + 4 + len(self.Uuid) + 4
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *FakeMessage) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeString(self.Email)
	if err != nil {
		return err
	}
	err = encoder.EncodeString(self.Ip)
	if err != nil {
		return err
	}
	err = encoder.EncodeString(self.Username)
	if err != nil {
		return err
	}
	err = encoder.EncodeString(self.Rfc3339)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt64(self.Unix)
	if err != nil {
		return err
	}
	err = encoder.EncodeString(self.Uuid)
	if err != nil {
		return err
	}
	err = encoder.EncodeUint32(self.Ran)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *FakeMessage) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Email)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Ip)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Username)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Rfc3339)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt64At(buf, offset, self.Unix)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalStringAt(buf, offset, self.Uuid)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalUint32At(buf, offset, self.Ran)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *FakeMessage) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Email = value
	}
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Ip = value
	}
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Username = value
	}
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Rfc3339 = value
	}
	{
		value, m, err := decoder.DecodeInt64()
		n += m
		if err != nil {
			return n, err
		}
		self.Unix = value
	}
	{
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return n, err
		}
		self.Uuid = value
	}
	{
		value, m, err := decoder.DecodeUint32()
		n += m
		if err != nil {
			return n, err
		}
		self.Ran = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *FakeMessage) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Email = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Ip = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Username = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Rfc3339 = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Unix = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Uuid = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Ran = value
	}
	return offset, nil
}
