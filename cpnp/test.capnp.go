// Code generated by capnpc-go. DO NOT EDIT.

package cpnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
)

type FakeMessage capnp.Struct

// FakeMessage_TypeID is the unique identifier for the type FakeMessage.
const FakeMessage_TypeID = 0xc5b8cbaac76274d4

func NewFakeMessage(s *capnp.Segment) (FakeMessage, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return FakeMessage(st), err
}

func NewRootFakeMessage(s *capnp.Segment) (FakeMessage, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return FakeMessage(st), err
}

func ReadRootFakeMessage(msg *capnp.Message) (FakeMessage, error) {
	root, err := msg.Root()
	return FakeMessage(root.Struct()), err
}

func (s FakeMessage) String() string {
	str, _ := text.Marshal(0xc5b8cbaac76274d4, capnp.Struct(s))
	return str
}

func (s FakeMessage) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (FakeMessage) DecodeFromPtr(p capnp.Ptr) FakeMessage {
	return FakeMessage(capnp.Struct{}.DecodeFromPtr(p))
}

func (s FakeMessage) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s FakeMessage) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s FakeMessage) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s FakeMessage) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s FakeMessage) Email() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s FakeMessage) HasEmail() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s FakeMessage) EmailBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s FakeMessage) SetEmail(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s FakeMessage) Ip() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s FakeMessage) HasIp() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s FakeMessage) IpBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s FakeMessage) SetIp(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s FakeMessage) Username() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s FakeMessage) HasUsername() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s FakeMessage) UsernameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s FakeMessage) SetUsername(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s FakeMessage) Rfc3339() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s FakeMessage) HasRfc3339() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s FakeMessage) Rfc3339Bytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s FakeMessage) SetRfc3339(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s FakeMessage) Unix() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s FakeMessage) SetUnix(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s FakeMessage) Uuid() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s FakeMessage) HasUuid() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s FakeMessage) UuidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s FakeMessage) SetUuid(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s FakeMessage) Ran() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s FakeMessage) SetRan(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

// FakeMessage_List is a list of FakeMessage.
type FakeMessage_List = capnp.StructList[FakeMessage]

// NewFakeMessage creates a new list of FakeMessage.
func NewFakeMessage_List(s *capnp.Segment, sz int32) (FakeMessage_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5}, sz)
	return capnp.StructList[FakeMessage](l), err
}

// FakeMessage_Future is a wrapper for a FakeMessage promised by a client call.
type FakeMessage_Future struct{ *capnp.Future }

func (f FakeMessage_Future) Struct() (FakeMessage, error) {
	p, err := f.Future.Ptr()
	return FakeMessage(p.Struct()), err
}
